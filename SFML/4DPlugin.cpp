/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : SFML
 #	author : miyako
 #	2017/06/26
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#if VERSIONWIN
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#endif

sf::SoundBuffer *audioBuffer;
sf::Sound *audioPlayer;
sf::SoundBufferRecorder *audioRecorder;

#pragma mark JSON

#if USE_JSON_CPP
#else

void json_conv(const char *value, std::wstring &u32) {
    
	if(value)
	{
		C_TEXT t;
		CUTF8String u8;
		
		u8 = (const uint8_t *)value;
		t.setUTF8String(&u8);
		
#if VERSIONWIN
		u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
		
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
#endif
	}else
	{
		u32 = L"";
	}
	
}

JSONNODE *json_parse_text_param(C_TEXT &t) {
    
	std::wstring u32;
	
#if VERSIONWIN
	u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
	
	uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
	std::vector<char> buf(dataSize);
	
	PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
														 t.getUTF16Length() * sizeof(PA_Unichar),
														 eVTC_UTF_16,
														 (char *)&buf[0],
														 dataSize,
														 eVTC_UTF_32);
	
	u32 = std::wstring((wchar_t *)&buf[0]);
#endif
	return json_parse((json_const json_char *)u32.c_str());
}

void json_set_text_param(JSONNODE *n, C_TEXT &t) {
    
	if(n)
	{
		json_char *json_string = json_write_formatted(n);
		
		std::wstring wstr = std::wstring(json_string);
		
#if VERSIONWIN
		t.setUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
		uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
		std::vector<char> buf(dataSize);
		
		uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																							wstr.length() * sizeof(wchar_t),
																							eVTC_UTF_32,
																							(char *)&buf[0],
																							dataSize,
																							eVTC_UTF_16);
		
		t.setUTF16String((const PA_Unichar *)&buf[0], len);
#endif
		
		json_free(json_string);
	}
	
}

BOOL json_get_stringA(JSONNODE *json, const wchar_t *name, std::string &value) {
    
	value = (const char *)"";
	
	if(json)
	{
		JSONNODE *node = json_get(json, name);
		if(node)
		{
			json_char *s =json_as_string(node);
			
			std::wstring wstr = std::wstring(s);
			
			C_TEXT t;
			
#if VERSIONWIN
			uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
			std::vector<char> buf(dataSize);
			
			uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																								wstr.length() * sizeof(wchar_t),
																								eVTC_UTF_16,
																								(char *)&buf[0],
																								dataSize,
																								eVTC_Win32Ansi);
			
			t.setUTF16String((const PA_Unichar *)&buf[0], len);
#endif
			
			CUTF8String v;
			t.copyUTF8String(&v);
			
			value = std::string((const char *)v.c_str(), v.length());
			
			json_free(s);
		}
	}
	
	return !!value.length();
}

BOOL json_get_string(JSONNODE *json, const wchar_t *name, std::string &value) {
    
	value = (const char *)"";
	
	if(json)
	{
		JSONNODE *node = json_get(json, name);
		if(node)
		{
			json_char *s =json_as_string(node);
			
			std::wstring wstr = std::wstring(s);
			
			C_TEXT t;
			
#if VERSIONWIN
			t.setUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
			uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
			std::vector<char> buf(dataSize);
			
			uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																								wstr.length() * sizeof(wchar_t),
																								eVTC_UTF_32,
																								(char *)&buf[0],
																								dataSize,
																								eVTC_UTF_16);
			
			t.setUTF16String((const PA_Unichar *)&buf[0], len);
#endif
			
			CUTF8String v;
			t.copyUTF8String(&v);
			
			value = std::string((const char *)v.c_str(), v.length());
			
			json_free(s);
		}
	}
	
	return !!value.length();
}

void json_set_text(JSONNODE *n, const wchar_t *name, char *value) {
    
	if(n)
	{
		if(value)
		{
			std::wstring w32;
			json_conv(value, w32);
			json_push_back(n, json_new_a(name, w32.c_str()));
		}
	}
}

void json_set_number(JSONNODE *n, const wchar_t *name, json_int_t value) {
    
	if(n)
	{
		json_push_back(n, json_new_i(name, value));
	}
}

#endif

#pragma mark Init / Deinit

bool IsProcessOnExit() {
    
     C_TEXT name;
     PA_long32 state, time;
     PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
     CUTF16String procName(name.getUTF16StringPtr());
     CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
     return (!procName.compare(exitProcName));
 }

void OnStartup() {
    
	audioBuffer = new sf::SoundBuffer;
	audioPlayer = new sf::Sound;
	audioRecorder = new sf::SoundBufferRecorder;
}

void OnExit() {
    
    delete audioBuffer;
    delete audioPlayer;
    delete audioRecorder;
}

//do this to make sure it is OK to unload AL before SFML

 void OnCloseProcess() {
     
     if(IsProcessOnExit()) {
         OnExit();
     }
 }

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		switch(pProcNum)
		{
			case kInitPlugin :
			case kServerInitPlugin :
				OnStartup();
				break;
                
            case kCloseProcess :
                OnCloseProcess();
                break;

			case 5 :
				SOUND_SET_DATA(params);
				break;
				
			case 15 :
				SOUND_Get_data(params);
				break;
				
			case 22 :
				EXPORT_AUDIO_FILE(params);
				break;
				
			case 23 :
				IMPORT_AUDIO_FILE(params);
				break;

			case 4 :
				SOUND_Stop_recording(params);
				break;
				
			default:
				CommandDispatcher(pProcNum, pResult, pParams);
				break;
		}

	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- AUDIO

		case 1 :
			GET_RECORDING_DEVICES(pResult, pParams);
			break;

		case 2 :
			Get_default_recording_device(pResult, pParams);
			break;

// --- Recording

		case 3 :
			SOUND_Start_recording(pResult, pParams);
			break;

// --- Playing

		case 6 :
			SOUND_SET_PITCH(pResult, pParams);
			break;

		case 7 :
			SOUND_Get_status(pResult, pParams);
			break;

		case 8 :
			SOUND_Get_pitch(pResult, pParams);
			break;

		case 9 :
			SOUND_SET_VOLUME(pResult, pParams);
			break;

		case 10 :
			SOUND_Get_volume(pResult, pParams);
			break;

		case 11 :
			SOUND_Get_position(pResult, pParams);
			break;

		case 12 :
			SOUND_SET_POSITION(pResult, pParams);
			break;

		case 13 :
			SOUND_SET_LOOP(pResult, pParams);
			break;

		case 14 :
			SOUND_Get_loop(pResult, pParams);
			break;

		case 16 :
			SOUND_Get_duration(pResult, pParams);
			break;

		case 17 :
			SOUND_Get_sample_rate(pResult, pParams);
			break;

		case 18 :
			SOUND_Get_channel_count(pResult, pParams);
			break;

		case 19 :
			SOUND_PLAY(pResult, pParams);
			break;

		case 20 :
			SOUND_PAUSE(pResult, pParams);
			break;

		case 21 :
			SOUND_STOP(pResult, pParams);
			break;

	}
}

// ------------------------------------- AUDIO ------------------------------------

#pragma mark -

void GET_RECORDING_DEVICES(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;

	if (sf::SoundBufferRecorder::isAvailable())
	{
#if VERSIONMAC
		std::vector<std::string> availableDevices = sf::SoundRecorder::getAvailableDevices();
		if(availableDevices.size())
		{
			Param1.setSize(1);
			for(size_t i=0; i < availableDevices.size(); ++i)
			{
				std::string inputDevice = availableDevices[i];
				Param1.appendUTF8String((const uint8_t *)inputDevice.c_str(), (uint32_t)inputDevice.length());
			}
		}
#else
		const ALchar* deviceList = alcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
		if(deviceList) Param1.setSize(1);
		while (*deviceList)
		{
			std::string deviceName = std::string(deviceList, strlen(deviceList));
			
			int len = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)deviceName.c_str(), deviceName.length(), NULL, 0);
			if (len) {
				std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
				if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)deviceName.c_str(), deviceName.length(), (LPWSTR)&buf[0], len)) {
					CUTF16String name = CUTF16String((const PA_Unichar *)&buf[0]);
					Param1.appendUTF16String(&name);
				}
			}
			deviceList += std::strlen(deviceList) + 1;
		}
#endif
	}
	Param1.toParamAtIndex(pParams, 1);
}

void Get_default_recording_device(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	if (sf::SoundBufferRecorder::isAvailable())
	{
#if VERSIONMAC
		std::string defaultDevice = sf::SoundBufferRecorder::getDefaultDevice();
		returnValue.setUTF8String((const uint8_t *)defaultDevice.c_str(), (uint32_t)defaultDevice.length());
#else
		const ALCchar *devicename = alcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);
		std::string defaultDevice = std::string(devicename, strlen(devicename));
		
		int len = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)defaultDevice.c_str(), defaultDevice.length(), NULL, 0);
		if (len) {
			std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
			if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)defaultDevice.c_str(), defaultDevice.length(), (LPWSTR)&buf[0], len)) {
				CUTF16String name = CUTF16String((const PA_Unichar *)&buf[0]);
				returnValue.setUTF16String(&name);
			}
		}
#endif
	}

	returnValue.setReturn(pResult);
}

// ----------------------------------- Recording ----------------------------------

#pragma mark Recording

void SOUND_Start_recording(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if (sf::SoundBufferRecorder::isAvailable())
	{
		unsigned int sampleRate = 44100;
		unsigned int channelCount = audioRecorder->getChannelCount();
		
#if VERSIONWIN
		const ALCchar *devicename = alcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);
		std::string defaultDevice = std::string(devicename, strlen(devicename));
#endif
		
		std::string device = audioRecorder->getDevice();

#if USE_JSON_CPP
        
        using namespace Json;
        using namespace std;
        CUTF8String u8;
        Param1.copyUTF8String(&u8);
        
        CharReaderBuilder builder;
        CharReader *reader = builder.newCharReader();
        
        Value root;
        string errors;
        
        bool parse = reader->parse((const char *)u8.c_str(),
                                   (const char *)u8.c_str() + u8.size(),
                                   &root,
                                   &errors);
        delete reader;
#else
        JSONNODE *json = json_parse_text_param(Param1);
#endif

#if USE_JSON_CPP
        if (parse)
#else
        if (json)
#endif
		{
            
#if USE_JSON_CPP
            Value _sampleRate = root["sampleRate"];
            if(_sampleRate.isNumeric()) {
                sampleRate = _sampleRate.asUInt();
            }
            Value _channelCount = root["channelCount"];
            if(_channelCount.isNumeric()) {
                channelCount = _channelCount.asUInt();
            }
#else
            JSONNODE *json_sampleRate = json_get(json, L"sampleRate");
            if(json_sampleRate) {
                sampleRate = (unsigned int)json_as_int(json_sampleRate);
            }
            JSONNODE *json_channelCount = json_get(json, L"channelCount");
            if(json_channelCount) {
                channelCount = (unsigned int)json_as_int(json_channelCount);
            }
#endif

			std::string deviceName;
 
#if USE_JSON_CPP
            Value _device = root["device"];
            if(_device.isString()) {
                deviceName = _device.asString();
#else
            #if VERSIONMAC
                        if(json_get_string(json, L"device", deviceName))
            #else
                        if(json_get_stringA(json, L"device", deviceName))
            #endif
			{
#endif
				if(deviceName.find(device) != 0)
				{
					audioRecorder->setDevice(deviceName);
				}
			}
#if VERSIONWIN
			else
			{
				audioRecorder->setDevice(defaultDevice);
			}
#endif
			audioRecorder->setChannelCount(channelCount);

#if USE_JSON_CPP
#else
            json_delete(json);
#endif
		}
		audioRecorder->start(sampleRate);
	}else
	{
		returnValue.setIntValue(-1);
	}
	
	returnValue.setReturn(pResult);
}

void SOUND_Stop_recording(PA_PluginParameters params) {
    
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	audioRecorder->stop();
	
	sf::SoundBuffer recordedBuffer = audioRecorder->getBuffer();
	
	sf::Time t = recordedBuffer.getDuration();
	std::string device = audioRecorder->getDevice();
	unsigned int sampleRate = audioRecorder->getSampleRate();
	unsigned int channelCount = audioRecorder->getChannelCount();
	
	sf::Uint64 sampleCount = recordedBuffer.getSampleCount();

	PA_ReturnBlob(params, (void *)recordedBuffer.getSamples(),
                  (PA_long32)(sampleCount * sizeof(sf::Int16)));
	
	C_TEXT Param1;
	
#if USE_JSON_CPP
    using namespace Json;
    Value root;
    root["duration"] = t.asMilliseconds();
    root["sampleRate"] = sampleRate;
    root["channelCount"] = channelCount;
    root["device"] = (char *)device.c_str();
    
    StreamWriterBuilder builder;
    builder["indentation"] = "";
    using namespace std;
    string json = writeString(builder, root);
    Param1.setUTF8String((const uint8_t *)json.c_str(), json.length());
#else
    JSONNODE *json = json_new(JSON_NODE);
    json_set_number(json, L"duration", t.asMilliseconds());
    json_set_number(json, L"sampleRate", sampleRate);
    json_set_number(json, L"channelCount", channelCount);
    json_set_text(json, L"device", (char *)device.c_str());
    json_set_text_param(json, Param1);
    json_delete(json);
#endif
    
	Param1.toParamAtIndex(pParams, 1);
}

// ------------------------------------ Playing -----------------------------------

#pragma mark PLAY

void SOUND_SET_DATA(PA_PluginParameters params) {
    
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	PA_Handle h = *(PA_Handle *)(pParams[0]);
	
	if(h)
	{
		audioBuffer->loadFromMemory((const void *)PA_LockHandle(h), (std::size_t)PA_GetHandleSize(h));
		PA_UnlockHandle(h);
	}
	
	audioPlayer->setBuffer((*(audioBuffer)));
}

void SOUND_Get_data(PA_PluginParameters params) {
    
	sf::Uint64 sampleCount = audioBuffer->getSampleCount();
	
	PA_ReturnBlob(params, (void *)audioBuffer->getSamples(), (PA_long32)(sampleCount * sizeof(sf::Int16)));
}

#pragma mark Properties

void SOUND_Get_status(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioPlayer->getStatus());
	returnValue.setReturn(pResult);
}

void SOUND_Get_duration(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioBuffer->getDuration().asMilliseconds());
	returnValue.setReturn(pResult);
}

void SOUND_Get_channel_count(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioBuffer->getChannelCount());
	returnValue.setReturn(pResult);
}

void SOUND_Get_sample_rate(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioBuffer->getSampleRate());
	returnValue.setReturn(pResult);
}

#pragma mark -

void SOUND_Get_pitch(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_REAL returnValue;
	
	returnValue.setDoubleValue(audioPlayer->getPitch());
	returnValue.setReturn(pResult);
}

void SOUND_SET_PITCH(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_REAL Param1;

	Param1.fromParamAtIndex(pParams, 1);
	audioPlayer->setPitch(Param1.getDoubleValue());
}

void SOUND_Get_volume(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_REAL returnValue;
	
	returnValue.setDoubleValue(audioPlayer->getVolume());
	returnValue.setReturn(pResult);
}

void SOUND_SET_VOLUME(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_REAL Param1;

	Param1.fromParamAtIndex(pParams, 1);
	audioPlayer->setVolume(Param1.getDoubleValue());
}

void SOUND_Get_position(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioPlayer->getPlayingOffset().asMilliseconds());
	returnValue.setReturn(pResult);
}

void SOUND_SET_POSITION(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	audioPlayer->setPlayingOffset(sf::milliseconds(Param1.getIntValue()));
}

void SOUND_Get_loop(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT returnValue;
	
	returnValue.setIntValue(audioPlayer->getLoop());
	returnValue.setReturn(pResult);
}

void SOUND_SET_LOOP(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	audioPlayer->setLoop(Param1.getIntValue());
}

#pragma mark Player

void SOUND_PLAY(sLONG_PTR *pResult, PackagePtr pParams) {
    
	audioPlayer->play();
}

void SOUND_PAUSE(sLONG_PTR *pResult, PackagePtr pParams) {
    
	audioPlayer->pause();
}

void SOUND_STOP(sLONG_PTR *pResult, PackagePtr pParams) {
    
	audioPlayer->stop();
}

#pragma mark -

// ------------------------------- Import and Export ------------------------------

#pragma mark Import / Export

void EXPORT_AUDIO_FILE(PA_PluginParameters params) {
    
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	CUTF8String path;
	Param1.copyPath(&path);
	std::string filename((const char *)path.c_str(), path.length());
	
	PA_Handle h = *(PA_Handle *)(pParams[1]);
	
	if((h) && PA_GetHandleSize(h))
	{
		C_LONGINT Param3;
		C_LONGINT Param4;
		Param3.fromParamAtIndex(pParams, 3);
		Param4.fromParamAtIndex(pParams, 4);
		unsigned int sampleRate = Param3.getIntValue();
		unsigned int channelCount = Param4.getIntValue();
		
		sf::SoundBuffer exportBuffer;
		exportBuffer.loadFromSamples((const sf::Int16 *)PA_LockHandle(h),
																 PA_GetHandleSize(h) / sizeof(sf::Int16),
																 channelCount, sampleRate);
		PA_UnlockHandle(h);
		exportBuffer.saveToFile(filename);
	}
	else
	{
		sf::SoundBuffer recordedBuffer = audioRecorder->getBuffer();
		recordedBuffer.saveToFile(filename);
	}

}

void IMPORT_AUDIO_FILE(PA_PluginParameters params) {
    
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	CUTF8String path;
	Param1.copyPath(&path);
	
	std::string filename((const char *)path.c_str(), path.length());
	audioBuffer->loadFromFile(filename);
	audioPlayer->setBuffer((*(audioBuffer)));
}

